Introduction:

This file describes changes that seem good, but that aren't worth
implementing in the prototype.  The changes are organized by file, so it will
be easy to find them when I come back to rewrite everything in C++.

messaging.py:

- Make the sender and receiver classes completely distinct.  If a game object
  wants to be able to send messages, it will contain a Sender object.
  Likewise, if it wants to receive messages, it will contain a Receiver
  object.  When messages are sent, they should contain a return address,
  because you can't send messages directly back to the sender.

- I could also use a factory class to make sender and receiver classes.  That
  way, the Messenger class wouldn't have to bother with managing address
  numbers so much.

managers/gui.py:

- The gui class is rather bloated.  It would probably be good to eventually
  split it up into smaller pieces somehow.  My thoughts right now are to keep
  the GUI class as an overall director.  There might be a Control class,
  which could pan the screen and move tokens.  Also, Mouse and Keyboard
  classes might be helpful.  SelectionBox and ViewBox classes might make
  sense.  

- There's no immediately obvious way to keep from scrolling off the map.
  This is something I'll want to think about when I do the C++ version.

- The distinction between world and screen coordinates is very sloppy and
  error-prone, as is.  For the C++ version, I'll want to handle this problem
  in a more elegant way.  Perhaps I could make screen and world coordinates
  different types of objects.  Maybe world coordinates would just be vectors,
  but screen coordinates would be a distinct class (within GUI) that could
  convert itself to world coordinates.  Of course, this would be more helpful
  in the strongly typed C++ than it would be in Python.

- The gui class currently keeps track of which dots are selected.  This makes 
  sense, because only dots controlled by the human player can be selected.  
  However, when a dot is killed, it needs to be removed from the gui's list of
  selected dots.  In order to do this, the gui will have to listen for kill
  messages relating to dots it knows about.  

tokens/dot.py:

- Dots decided that they have arrived at a point when that point comes within
  their radius.  This isn't great logic, but it was simple and I'm not sure
  how to do better.
